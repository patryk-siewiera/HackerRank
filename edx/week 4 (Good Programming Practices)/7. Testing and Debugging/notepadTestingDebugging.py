"""
week 4 - testing and debugging

- defensive programming
	- write specifications for functions
	- modularize programs
	- check conditions on inputs / outputs (assertions)

- testing
	- compare input / output pairs to specification
	- its not working!
	- how can i break my program? 

- eliminate source of bugs - debugging 
	- study events - leading up to an error
	- why is it not working?
	- how can I fix my program?

CLASS OF TESTS
- from the start, design code to ease this part
- break program into modules that can be tested and debugged individually
- document constraints on modules
	- what do you expect the input to be? the output to be?
- document assumptions behind code design 

WHEN ARE YOU READY TO TEST?
- ensure code runs
	- remove syntax errors
	- remove static semantic errors
	- Python interpreter can usually find these for you
- have a set of expected results
	- an input set
	- for each input, the expected output 

CLASSES OF TESTS:
- UNIT TESTING
	- validate each piece of program
	- TESTING EACH FUNCTION SEPARATLY
- REGRESSION TESTING
	- add test for bugs as you find them in a function
	- CATCH REINTRODUCED errors that were previously fixed
- INTEGRATION TESTING
	- does OVERALL PROGRAM WORK?
	- >>tend to rush to do this<<

TESTING APPROACHES:
- 
"""

